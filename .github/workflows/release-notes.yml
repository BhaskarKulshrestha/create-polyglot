name: Generate Release Notes

on:
  release:
    types: [created, published]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag name for the release'
        required: true
        type: string
      target_commitish:
        description: 'Target branch or commit (default: main)'
        required: false
        default: 'main'
        type: string

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get release information
        id: release_info
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.tag_name }}"
            TARGET_COMMITISH="${{ github.event.inputs.target_commitish }}"
          else
            TAG_NAME="${{ github.event.release.tag_name }}"
            TARGET_COMMITISH="${{ github.event.release.target_commitish }}"
          fi
          
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "target_commitish=$TARGET_COMMITISH" >> $GITHUB_OUTPUT
          
          # Get previous tag
          PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -v "$TAG_NAME" | head -n 1)
          if [ -z "$PREVIOUS_TAG" ]; then
            # If no previous tag, use first commit
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
          
          # Get version without 'v' prefix
          VERSION=${TAG_NAME#v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Generate categorized commit list
        id: categorize_commits
        run: |
          # Create arrays for different categories
          declare -a features=()
          declare -a bugfixes=()
          declare -a breaking=()
          declare -a documentation=()
          declare -a internal=()
          declare -a dependencies=()
          declare -a other=()
          
          # Get commits since last release
          COMMITS=$(git log ${{ steps.release_info.outputs.previous_tag }}..${{ steps.release_info.outputs.tag_name }} --pretty=format:"%h|%s|%an" --no-merges)
          
          # Categorize commits
          while IFS='|' read -r hash subject author; do
            if [[ -z "$hash" ]]; then continue; fi
            
            # Convert to lowercase for matching
            lower_subject=$(echo "$subject" | tr '[:upper:]' '[:lower:]')
            
            if [[ $lower_subject =~ ^feat(\(.*\))?!: ]] || [[ $lower_subject =~ breaking ]]; then
              breaking+=("- $subject ([${hash}](https://github.com/${{ github.repository }}/commit/${hash})) by @${author}")
            elif [[ $lower_subject =~ ^feat(\(.*\))?: ]] || [[ $lower_subject =~ ^add ]] || [[ $lower_subject =~ ^implement ]]; then
              features+=("- $subject ([${hash}](https://github.com/${{ github.repository }}/commit/${hash})) by @${author}")
            elif [[ $lower_subject =~ ^fix(\(.*\))?: ]] || [[ $lower_subject =~ ^bug ]] || [[ $lower_subject =~ ^patch ]]; then
              bugfixes+=("- $subject ([${hash}](https://github.com/${{ github.repository }}/commit/${hash})) by @${author}")
            elif [[ $lower_subject =~ ^docs(\(.*\))?: ]] || [[ $lower_subject =~ documentation ]] || [[ $lower_subject =~ readme ]]; then
              documentation+=("- $subject ([${hash}](https://github.com/${{ github.repository }}/commit/${hash})) by @${author}")
            elif [[ $lower_subject =~ ^chore(\(.*\))?: ]] || [[ $lower_subject =~ ^ci(\(.*\))?: ]] || [[ $lower_subject =~ ^test(\(.*\))?: ]] || [[ $lower_subject =~ ^refactor(\(.*\))?: ]]; then
              internal+=("- $subject ([${hash}](https://github.com/${{ github.repository }}/commit/${hash})) by @${author}")
            elif [[ $lower_subject =~ ^deps(\(.*\))?: ]] || [[ $lower_subject =~ dependencies ]] || [[ $lower_subject =~ package ]] || [[ $lower_subject =~ bump ]]; then
              dependencies+=("- $subject ([${hash}](https://github.com/${{ github.repository }}/commit/${hash})) by @${author}")
            else
              other+=("- $subject ([${hash}](https://github.com/${{ github.repository }}/commit/${hash})) by @${author}")
            fi
          done <<< "$COMMITS"
          
          # Export arrays as multiline strings
          printf '%s\n' "${features[@]}" > features.txt
          printf '%s\n' "${bugfixes[@]}" > bugfixes.txt
          printf '%s\n' "${breaking[@]}" > breaking.txt
          printf '%s\n' "${documentation[@]}" > documentation.txt
          printf '%s\n' "${internal[@]}" > internal.txt
          printf '%s\n' "${dependencies[@]}" > dependencies.txt
          printf '%s\n' "${other[@]}" > other.txt

      - name: Get contributors
        id: contributors
        run: |
          # Get unique contributors for this release
          CONTRIBUTORS=$(git log ${{ steps.release_info.outputs.previous_tag }}..${{ steps.release_info.outputs.tag_name }} --pretty=format:"%an" --no-merges | sort -u | sed 's/^/- @/' | tr '\n' '\n')
          echo "contributors<<EOF" >> $GITHUB_OUTPUT
          echo "$CONTRIBUTORS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: generate_notes
        run: |
          # Read template
          TEMPLATE=$(cat .github/release-notes-template.md)
          
          # Read categorized sections
          FEATURES=$(cat features.txt || echo "No new features in this release.")
          BUGFIXES=$(cat bugfixes.txt || echo "No bug fixes in this release.")
          BREAKING=$(cat breaking.txt || echo "No breaking changes in this release.")
          DOCUMENTATION=$(cat documentation.txt || echo "No documentation changes in this release.")
          INTERNAL=$(cat internal.txt || echo "No internal changes in this release.")
          DEPENDENCIES=$(cat dependencies.txt || echo "No dependency updates in this release.")
          OTHER=$(cat other.txt || echo "No other changes in this release.")
          
          # Replace placeholders
          NOTES="$TEMPLATE"
          NOTES="${NOTES//\{version\}/${{ steps.release_info.outputs.version }}}"
          NOTES="${NOTES//\{features\}/$FEATURES}"
          NOTES="${NOTES//\{bugfixes\}/$BUGFIXES}"
          NOTES="${NOTES//\{breaking\}/$BREAKING}"
          NOTES="${NOTES//\{documentation\}/$DOCUMENTATION}"
          NOTES="${NOTES//\{internal\}/$INTERNAL}"
          NOTES="${NOTES//\{dependencies\}/$DEPENDENCIES}"
          NOTES="${NOTES//\{other\}/$OTHER}"
          NOTES="${NOTES//\{refactoring\}/No refactoring changes in this release.}"
          NOTES="${NOTES//\{compare_url\}/https://github.com/${{ github.repository }}/compare/${{ steps.release_info.outputs.previous_tag }}...${{ steps.release_info.outputs.tag_name }}}"
          NOTES="${NOTES//\{contributors\}/${{ steps.contributors.outputs.contributors }}}"
          NOTES="${NOTES//\{commits\}/[View all commits](https://github.com/${{ github.repository }}/compare/${{ steps.release_info.outputs.previous_tag }}...${{ steps.release_info.outputs.tag_name }})}"
          
          # Add placeholder sections for manual editing
          NOTES="${NOTES//\{upgrade_notes\}/<!-- Add any upgrade notes or migration steps here -->}"
          NOTES="${NOTES//\{known_issues\}/<!-- Add any known issues or caveats here -->}"
          
          # Save to file
          echo "$NOTES" > release-notes.md
          
          # Also set as output for updating release
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update release with generated notes
        if: github.event_name == 'release'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const releaseNotes = fs.readFileSync('release-notes.md', 'utf8');
            
            // Get the current release
            const release = await github.rest.repos.getReleaseByTag({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag: '${{ steps.release_info.outputs.tag_name }}'
            });
            
            // Update the release with generated notes
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              body: releaseNotes
            });
            
            console.log('Release notes updated successfully!');

      - name: Create draft release (for manual dispatch)
        if: github.event_name == 'workflow_dispatch'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const releaseNotes = fs.readFileSync('release-notes.md', 'utf8');
            
            try {
              // Try to get existing release
              const existingRelease = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: '${{ steps.release_info.outputs.tag_name }}'
              });
              
              // Update existing release
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: existingRelease.data.id,
                body: releaseNotes
              });
              
              console.log('Existing release updated with generated notes!');
            } catch (error) {
              if (error.status === 404) {
                // Create new draft release
                const release = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: '${{ steps.release_info.outputs.tag_name }}',
                  target_commitish: '${{ steps.release_info.outputs.target_commitish }}',
                  name: `Release ${{ steps.release_info.outputs.version }}`,
                  body: releaseNotes,
                  draft: true,
                  prerelease: false
                });
                
                console.log(`Draft release created: ${release.data.html_url}`);
              } else {
                throw error;
              }
            }

      - name: Upload release notes as artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes-${{ steps.release_info.outputs.version }}
          path: release-notes.md
          retention-days: 30