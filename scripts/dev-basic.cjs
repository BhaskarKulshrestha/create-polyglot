const { spawn } = require('node:child_process');
const fs = require('fs');
const path = require('path');

// Root of the repo (assumes script is run from project root via npm script)
const root = process.cwd();

// Convention: all services generated by the scaffold live under services/
// (Older versions used apps/; that was replaced to avoid confusion with Next.js)
const servicesDir = path.join(root, 'services');

if (!fs.existsSync(servicesDir)) {
  console.warn('âš ï¸  services/ directory not found. No local services will be started.');
  process.exit(0);
}

// Initialize logging for all services
function initializeLogging() {
  const services = fs.readdirSync(servicesDir);
  services.forEach(svc => {
    const svcPath = path.join(servicesDir, svc);
    const logsDir = path.join(svcPath, '.logs');
    
    // Create logs directory
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }
    
    // Create logger helper
    const loggerPath = path.join(logsDir, 'logger.js');
    if (!fs.existsSync(loggerPath)) {
      const loggerHelper = `// Auto-generated logger helper for polyglot services
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const LOG_LEVELS = {
  error: 4,
  warn: 3,
  info: 2,
  debug: 1
};

export class Logger {
  constructor(serviceName = 'unknown') {
    this.serviceName = serviceName;
    this.logsDir = __dirname;
  }
  
  log(level, message, data = {}) {
    try {
      const logEntry = {
        timestamp: new Date().toISOString(),
        level: level.toLowerCase(),
        service: this.serviceName,
        message: String(message),
        data
      };
      
      const dateStr = new Date().toISOString().split('T')[0];
      const logFile = path.join(this.logsDir, \`\${dateStr}.log\`);
      const logLine = JSON.stringify(logEntry) + '\\n';
      
      fs.appendFileSync(logFile, logLine);
    } catch (e) {
      console.error('Failed to write log:', e.message);
    }
  }
  
  error(message, data) { this.log('error', message, data); }
  warn(message, data) { this.log('warn', message, data); }
  info(message, data) { this.log('info', message, data); }
  debug(message, data) { this.log('debug', message, data); }
}
`;
      fs.writeFileSync(loggerPath, loggerHelper);
    }
  });
}

// Start admin dashboard
function startAdminDashboard() {
  console.log('ðŸŽ›ï¸  Starting admin dashboard...');
  
  // Try to find create-polyglot globally or in node_modules
  let adminCmd = 'npx';
  let adminArgs = ['create-polyglot', 'admin', '--port', '9000'];
  
  // Fallback: check if create-polyglot is available globally
  try {
    const { execSync } = require('child_process');
    execSync('which create-polyglot', { stdio: 'ignore' });
    adminCmd = 'create-polyglot';
    adminArgs = ['admin', '--port', '9000'];
  } catch (e) {
    // Use npx as fallback
  }
  
  const adminProcess = spawn(adminCmd, adminArgs, {
    cwd: root,
    env: process.env,
    stdio: 'pipe'
  });
  
  adminProcess.stdout.on('data', d => process.stdout.write(`[admin] ${d}`));
  adminProcess.stderr.on('data', d => process.stderr.write(`[admin] ${d}`));
  adminProcess.on('exit', code => {
    if (code !== 0) {
      console.log(`[admin] Admin dashboard failed to start (code ${code}). Continuing without dashboard...`);
    }
  });
  
  // Don't fail the whole process if admin fails
  adminProcess.on('error', (err) => {
    console.log(`[admin] Admin dashboard not available: ${err.message}. Continuing without dashboard...`);
  });
  
  return adminProcess;
}

// Initialize logging for all services
initializeLogging();

// Snapshot the list of entries inside services/ (folders assumed to be services)
const services = fs.readdirSync(servicesDir);

// Determine the root package manager heuristically
function detectPM() {
  // Heuristic: look for lock files in order of preference.
  // If multiple exist (rare / misconfigured), first match wins.
  if (fs.existsSync(path.join(root, 'pnpm-lock.yaml'))) return 'pnpm';
  if (fs.existsSync(path.join(root, 'yarn.lock'))) return 'yarn';
  if (fs.existsSync(path.join(root, 'bun.lockb'))) return 'bun';
  // Fallback to npm when no known lockfile is detected.
  return 'npm';
}
const pm = detectPM();

if (services.length === 0) {
  // Nothing inside services/; we exit early (not an error condition).
  console.log('No Node-based services with package.json to run.');
  process.exit(0);
}

console.log(`Using package manager: ${pm}`);
console.log(`Discovered services: ${services.join(', ')}`);

// Keep references to spawned child processes so we can forward signals.
const procs = [];

// Start admin dashboard first
const adminProc = startAdminDashboard();
procs.push(adminProc);

function prefix(name, data) {
  // Prepend the service name to each line of output for readability.
  // NOTE: data may contain multiple lines; we leave asâ€‘is to avoid splitting.
  process.stdout.write(`[${name}] ${data}`);
}

services.forEach((svc) => {
  const svcPath = path.join(servicesDir, svc);
  const pkgPath = path.join(svcPath, 'package.json');

  if (!fs.existsSync(pkgPath)) {
    // Non-Node service (e.g., python, go, java). Skip silently with context.
    console.log(`Skipping ${svc} (no package.json; likely non-Node service)`);
    return;
  }

  try {
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
    if (!pkg.scripts || !pkg.scripts.dev) {
      // Node project present but without a dev script; user may add later.
      console.log(`Skipping ${svc} (no dev script)`);
      return;
    }
    // Determine spawn command + arguments.
    // For yarn classic, `yarn dev` would also work, but keeping uniform form.
    const cmd = pm === 'bun' ? 'bun' : pm; // direct binary (npm, pnpm, yarn, bun)
    const args = pm === 'yarn' ? ['run', 'dev'] : pm === 'bun' ? ['run', 'dev'] : ['run', 'dev'];
    // Could special-case: if (pm==='yarn') args=['dev'] but current pattern is fine.
    const child = spawn(cmd, args, { cwd: svcPath, shell: true, env: process.env });
    procs.push(child);
    child.stdout.on('data', d => prefix(svc, d));
    child.stderr.on('data', d => prefix(svc, d));
    child.on('exit', code => {
      // Log exit so the developer sees early failures.
      console.log(`[${svc}] exited with code ${code}`);
    });
  } catch (e) {
    // JSON parse errors or spawn failures bubble here.
    console.log(`Failed to start ${svc}:`, e.message);
  }
});

process.on('SIGINT', () => {
  // Graceful shutdown: forward Ctrl+C to each child, then exit.
  procs.forEach(p => p.kill('SIGINT'));
  process.exit(0);
});
